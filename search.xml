<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[折腾笔记]小狼毫输入法</title>
      <link href="//post/61849.html"/>
      <url>//post/61849.html</url>
      
        <content type="html"><![CDATA[<p>之前一直在用搜狗，但是搜狗最近越来越不好用了，各种广告AI满天飞，有的时候后台占用比Edge还大，就离谱。所以我就去网上搜索开源的轻量输入法，就找到了小狼毫</p><h3 id="基础安装"><a href="#基础安装" class="headerlink" title="基础安装"></a>基础安装</h3><p>首先前往<a href="https://rime.im/">这里</a>去下载一个合适的版本，然后一路安装（如果不想后期太麻烦我建议选择默认用户文件夹📁）</p><p>安装完成后直接用还是稍微有点难用的，暂且不说让人感到爆炸的默认UI，难用的输入联想，令人感到不安的配置文档。光快捷键就很让人不舒服了。所以我们得进行一些小小的个性化设置</p><h3 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h3><p>Tips:更多相关项目可以前往<a href="https://github.com/rime">RIME</a>查看</p><h4 id="安装雾凇拼音包"><a href="#安装雾凇拼音包" class="headerlink" title="安装雾凇拼音包"></a>安装雾凇拼音包</h4><p>首先前往<a href="https://github.com/iDvel/rime-ice">iDvel&#x2F;rime-ice: Rime 配置：雾凇拼音 | 长期维护的简体词库</a>将整个项目打包下载，然后将目前的输入法设置为小狼毫，右键小狼毫旁的“中”字图标，选择“用户文件夹”<br><img src="https://raw.githubusercontent.com/HongShi211/blog/main/Qexo/25/10/xlh01_cef4a7efb2623e33baa5a6e1c383e742.jpg" alt="01"></p><p>我们需要将下载到的压缩包直接解压到用户文件夹中，完成后再次右击小狼毫旁的“中”字图标，选择“重新部署”稍等片刻后就加载完成了。但是此时还没有切换到我们安装的拼音包，我们需要右击小狼毫旁的“中”字图标，选择“输入法设定”，在弹出窗口中勾选雾凇拼音，并点击河南按钮（中，bushi）即可。完成后，我们需要按住键盘上的Ctrl+~，选择雾凇拼音，即可完成拼音设置。</p><h4 id="自定义输入法主题"><a href="#自定义输入法主题" class="headerlink" title="自定义输入法主题"></a>自定义输入法主题</h4><p>我个人推荐使用两个工具。</p><p>第一个是可视化配置程序：<a href="https://github.com/qzly/RimeControl">qzly&#x2F;RimeControl</a></p><p>第二个是在线调整一些功能的github pages：<a href="https://pdog18.github.io/rime-soak/">润笔</a></p><p>这是他的仓库（现已不再维护）：<a href="https://github.com/pdog18/rime-soak">pdog18&#x2F;rime-soak: Rime 设置助手</a></p><p>有了这两个工具，我们就可以告别那些恼人的yml配置文档了</p><h4 id="导入搜狗词库"><a href="#导入搜狗词库" class="headerlink" title="导入搜狗词库"></a>导入搜狗词库</h4><p>不得不说，搜狗在词库方面还是很权威的，为了使用体验更好一点，我建议各位可以导入搜狗的词库。</p><p>我们需要一个小工具，可以去<a href="https://github.com/studyzy/imewlconverter">studyzy&#x2F;imewlconverter</a>下载</p><p>我们先获取我们之前一直用的搜狗的个人词库，来到搜狗输入法的设置页面，选择词库，导出&#x2F;备份，得到一份bin文件。如果你想要补充，可以前往<a href="https://pinyin.sogou.com/dict/">搜狗细胞词库_词库下载_词典_输入法字典</a>这里下载想要的词库，下载完成后打开我们的词库转换器，把所有你要的词库文件都拖进去，此时深蓝词库转换会自动识别输入格式，我们仅需要把输出设置为Rime中州韵即可。出现弹窗选择自己的操作系统，将文件取名并保存到一个你能找到的地方，然后，你需要新建一个名为<strong>sogou_supplement.dict.yaml</strong>的文件，文件前几行为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Rime dictionary</span><br><span class="line"># encoding: utf-8</span><br><span class="line">---</span><br><span class="line">name: sogou_supplement</span><br><span class="line">version: &quot;2025.10.02&quot;</span><br><span class="line">sort: by_weight</span><br><span class="line">use_preset_vocabulary: false</span><br><span class="line">import_tables: []</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接下来打开转换的文件，将所有内容复制到…的下一行，我们的词库已经准本好了，就剩下导入了。</p><p>接下来，我们要去到用户文件夹，找到一个名为default.custom.yaml的文件，在path下增加几行代码（如下，注意缩进！！！！）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">patch:</span><br><span class="line">  &quot;*/translator/import_tables/+&quot;:</span><br><span class="line">    - sogou_supplement</span><br></pre></td></tr></table></figure><p>如果需要更新，直接找到创建的<strong>sogou_supplement.dict.yaml</strong>文件，在后面追加就行了。</p><h4 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h4><p>但是这两个工具还不太很够，有些人（比如我）就喜欢有一些自定义的快捷键，比如⬅️➡️切换候选字，[]翻页，按shift切到英文且保留候选栏字符等。这些都可以通过用户文件夹中的yml配置文件来实现，下面是一些比较常见的快捷键设置。</p><p>（以下均在 <code>%AppData%\Rime\*.custom.yaml</code> 里完成，改完右键托盘图标 → 重新部署即可生效）</p><ol><li>中英文快速切换</li><li>简繁体一键切换</li><li>翻页 &#x2F; 删除用户词 &#x2F; 临时英文模式等效率键</li></ol><p>下面给出「最小可运行」示例，复制即可用；如需更多按键，在同类节点下继续追加即可。</p><ol><li><p>中英文切换（左 Shift 直接切，右 Shift 当「临时大写」用就松手回中文）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 文件：default.custom.yaml</span><br><span class="line">patch:</span><br><span class="line">  key_binder:</span><br><span class="line">    bindings:</span><br><span class="line">      # 单击左 Shift → 切到英文</span><br><span class="line">      - &#123; when: always, accept: Shift_L, toggle: ascii_mode &#125;</span><br><span class="line">      # 右 Shift 仅临时大写，松手即回中文（already default，写这里方便你改）</span><br><span class="line">      - &#123; when: composing, accept: Shift_R, send: Escape &#125;</span><br></pre></td></tr></table></figure></li><li><p>简繁体一键切换（例：Ctrl + Shift + F）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 文件：default.custom.yaml</span><br><span class="line">patch:</span><br><span class="line">  key_binder:</span><br><span class="line">    bindings:</span><br><span class="line">      # 注意 toggle 名要与 schema 里 switches 节点保持一致</span><br><span class="line">      - &#123; when: always, accept: &quot;Control+Shift+F&quot;, toggle: zh_trad &#125;</span><br></pre></td></tr></table></figure></li><li><p>候选词翻页（习惯 ,&#x2F;. 或 –&#x2F;&#x3D; 均可）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">patch:</span><br><span class="line">  key_binder:</span><br><span class="line">    bindings:</span><br><span class="line">      - &#123; when: has_menu, accept: comma, send: Page_Up &#125;</span><br><span class="line">      - &#123; when: has_menu, accept: period, send: Page_Down &#125;</span><br></pre></td></tr></table></figure></li><li><p>删除误上屏的用户词（立即后悔键）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patch:</span><br><span class="line">  key_binder:</span><br><span class="line">    bindings:</span><br><span class="line">      - &#123; when: has_menu, accept: Control+Delete, send: unpublish_candidate &#125;</span><br></pre></td></tr></table></figure><p>下面是修改流程</p><ol><li>打开用户目录<br>托盘图标右键 → 「用户文件夹」即可进入 <code>%AppData%\Rime</code>。</li><li>新建 &#x2F; 编辑 <code>default.custom.yaml</code>（没有就新建，已有就追加 <code>patch:</code> 节点）。</li><li>保存后仍右键托盘 → 「重新部署」；看到状态栏提示「部署完成」即可测试新键。</li></ol></li></ol><h3 id="系统默认输入法设置"><a href="#系统默认输入法设置" class="headerlink" title="系统默认输入法设置"></a>系统默认输入法设置</h3><p>目前属于你的输入法已经配置完了，接下来就是使用了，我们只需要在Windows设置-&gt;时间和语言-&gt;语言-&gt;键盘-&gt;替代默认输入法改为小狼毫即可。</p><p>大功告成！去享受这个轻量美丽的输入法吧！</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
          <category> 折腾笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 折腾笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dolphin逆向思路+过程</title>
      <link href="//post/42496.html"/>
      <url>//post/42496.html</url>
      
        <content type="html"><![CDATA[<p>十一到处逛，在L站发现了个帖子<a href="https://linux.do/t/topic/1002906">发现一个AI（可免费使用） - 开发调优 - LINUX DO</a>我注意到有些站点并没有严格的鉴权限制，甚至允许未登录的用户直接调用模型接口。这类接口往往隐藏在浏览器的网络请求中，通过分析可以实现标准化调用，从而兼容 OpenAI 的 API 生态。下面记录一下我对 <strong>Dolphin 模型接口</strong> 的逆向过程与思路。</p><h4 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h4><p>目标网站提供了一个在线对话页面，前端直接与模型服务交互：</p><ul><li>请求地址：<code>https://chat.dphn.ai/api/chat</code></li><li>请求方法：<code>POST</code></li><li>返回格式：<code>text/event-stream</code>（SSE 流式返回）</li></ul><p>这里的关键点是 <strong>数据并不是普通 JSON，而是通过 SSE 逐条传输</strong>，这意味着需要模拟流式读取。</p><h4 id="观察请求参数"><a href="#观察请求参数" class="headerlink" title="观察请求参数"></a>观察请求参数</h4><p>通过浏览器开发者工具（Network 面板），我们可以看到完整的请求：</p><ul><li><code>Content-Type: application/json</code></li><li><code>Accept: text/event-stream</code></li><li>请求体包含：<ul><li><code>messages</code>（聊天上下文，符合 OpenAI 格式）</li><li><code>model</code>（例如 <code>dolphinpod:24B</code>）</li><li><code>template</code>（推理模式，如 <code>&quot;logical&quot;</code>）</li></ul></li></ul><blockquote><p>📌 这一步确认了接口 <strong>几乎与 OpenAI Chat API 一致</strong>，只是多了一个 <code>template</code> 字段。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;messages&quot;: [</span><br><span class="line">    &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你是谁？&quot;&#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;model&quot;: &quot;dolphinpod:24B&quot;,</span><br><span class="line">  &quot;template&quot;: &quot;logical&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="处理-SSE-流式返回"><a href="#处理-SSE-流式返回" class="headerlink" title="处理 SSE 流式返回"></a>处理 SSE 流式返回</h4><p>返回的数据不是一次性 JSON，而是 <strong>逐行推送的 SSE</strong>。每一行类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;&quot;choices&quot;:[&#123;&quot;delta&quot;:&#123;&quot;content&quot;:&quot;你好&quot;&#125;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>需要在客户端逐行解析，提取 <code>delta.content</code> 并拼接成最终结果。<br>这与 OpenAI <code>stream=True</code> 的机制完全一致。</p><h4 id="构建代理层思路"><a href="#构建代理层思路" class="headerlink" title="构建代理层思路"></a>构建代理层思路</h4><p>由于原始接口并没有统一的 API Key 验证机制，如果想要对外安全暴露，需要自己加一层 <strong>代理服务</strong>：</p><ol><li><strong>转发请求</strong>：<ul><li>外部调用 <code>/v1/chat/completions</code></li><li>代理服务转发到 <code>https://chat.dphn.ai/api/chat</code></li></ul></li><li><strong>兼容 OpenAI 格式</strong>：<ul><li>输入&#x2F;输出保持与 OpenAI SDK 一致</li><li>方便用户直接用 <code>openai.ChatCompletion.create()</code> 调用</li></ul></li><li><strong>自定义鉴权</strong>：<ul><li>在代理层添加 API Key 校验</li><li>保证只有授权用户可以访问</li></ul></li></ol><h4 id="关键难点与解决思路"><a href="#关键难点与解决思路" class="headerlink" title="关键难点与解决思路"></a>关键难点与解决思路</h4><ul><li><strong>SSE 转发</strong><ul><li>不能直接 <code>resp.json()</code>，必须逐行解析</li><li>需要在服务端用 <code>StreamingResponse</code>（Python）或 <code>ReadableStream</code>（Deno）转发</li></ul></li><li><strong>浏览器伪装</strong><ul><li>有些站点可能检查 <code>Origin</code> 和 <code>Referer</code></li><li>需要在请求头中补全这两个字段</li></ul></li><li><strong>模型列表</strong><ul><li>原站点没有 <code>/v1/models</code> 接口</li><li>可以在代理层手动定义可用模型（如 <code>dolphinpod:24B</code>）</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>整个逆向过程的关键是：</p><ol><li><strong>观察请求</strong> → 确认接口是 <code>/api/chat</code>，参数与 OpenAI 格式类似</li><li><strong>理解响应</strong> → 识别是 SSE 流式输出，逐行解析</li><li><strong>设计代理</strong> → 实现 <code>/v1/chat/completions</code> 与 <code>/v1/models</code>，加上 API Key 保护</li><li><strong>统一调用</strong> → 让外部可以直接用 OpenAI SDK 访问 Dolphin 模型</li></ol><p>通过这种方式，任何支持 OpenAI API 的工具（如 LangChain、ChatUI）都可以无缝切换到 Dolphin 模型。</p><p>行了，完事儿了</p><p>完整代码前往：<a href="https://linux.do/t/topic/1003204">dolphin2api-我写的第二个2api - 开发调优 &#x2F; 开发调优, Lv2 - LINUX DO</a></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deepinfra逆向思路+过程</title>
      <link href="//post/62072.html"/>
      <url>//post/62072.html</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前几天在网上冲浪的时候发现一个网站，叫<a href="https://deepinfra.com/">Deepinfra</a>，点击去发现是一个AI的网站，有意思的是网站首页有一个对话页面，这个页面似乎是可以直接调用站内AI的，而且没有次数、内容限制。</p><p>于是我就打开F12，发了条消息打算抓一下然后有意思的就来了。<img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image-TLck.png"></p><p>这个comletions直接请求<a href="https://api.deepinfra.com/v1/openai/chat/completions">https://api.deepinfra.com/v1/openai/chat/completions</a> ，这个地址与OpenAI的标准格式有一些差距，而且我找了一大圈都没找到cookie或者别的用于鉴权的东西，似乎它前端没有做鉴权，我试着在python中把调用地址填好，编了一个key，居然调用成功了，还是流式的</p><p>那么事情很有意思了，其实到这一步就已经可以了，能直接去填一下模型名直接去用。但是我想要把它接入到我的API站里，那么我就要做点多余的事了。</p><p>目标：标准OpenAI格式调用，能通过&#x2F;v1&#x2F;models获取模型列表，自定义API KEY限制请求。</p><p>首先这个项目的基调已经定下了，是2api，那么我们就需要选一个合适的语言，方便部署的同时也要足够优雅，我选择了用Deno去写。</p><h4 id="开写！"><a href="#开写！" class="headerlink" title="开写！"></a>开写！</h4><p>首先要获取模型列表，我原本打算照着请求一个个去薅，但是我突然发现他们有官方的API文档，就直接进去了，里面有首页能调用的模型，就直接copy过来用了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const SUPPORTED_MODELS = [</span><br><span class="line">  &#123; id: &quot;openai/gpt-oss-120b&quot;, object: &quot;model&quot; &#125;,</span><br><span class="line">  &#123; id: &quot;moonshotai/Kimi-K2-Instruct&quot;, object: &quot;model&quot; &#125;,</span><br><span class="line">  &#123; id: &quot;zai-org/GLM-4.5&quot;, object: &quot;model&quot; &#125;,</span><br><span class="line">  &#123; id: &quot;Qwen/Qwen3-Coder-480B-A35B-Instruct-Turbo&quot;, object: &quot;model&quot; &#125;,</span><br><span class="line">  &#123; id: &quot;deepseek-ai/DeepSeek-R1-0528-Turbo&quot;, object: &quot;model&quot; &#125;,</span><br><span class="line">  &#123; id: &quot;deepseek-ai/DeepSeek-V3-0324-Turbo&quot;, object: &quot;model&quot; &#125;,</span><br><span class="line">  &#123; id: &quot;meta-llama/Llama-4-Maverick-17B-128E-Instruct-Turbo&quot;, object: &quot;model&quot; &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>模型列表搞定之后，就该整一下模型列表和completions接口了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">serve(async (req: Request) =&gt; &#123;</span><br><span class="line">  const url = new URL(req.url);</span><br><span class="line"></span><br><span class="line">  if (req.method === &quot;GET&quot; &amp;&amp; url.pathname === &quot;/v1/models&quot;) &#123;</span><br><span class="line">    return new Response(JSON.stringify(&#123;</span><br><span class="line">      object: &quot;list&quot;,</span><br><span class="line">      data: SUPPORTED_MODELS</span><br><span class="line">    &#125;), &#123;</span><br><span class="line">      status: 200,</span><br><span class="line">      headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (req.method === &quot;POST&quot; &amp;&amp; url.pathname === &quot;/v1/chat/completions&quot;) &#123;</span><br><span class="line">    const body = await req.text();</span><br><span class="line">    const headers = new Headers(req.headers);</span><br></pre></td></tr></table></figure><p>完事儿还有自定义key，不能是个东西就过来刷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const VALID_API_KEYS = [&quot;sk-1&quot;, &quot;sk-2&quot;];</span><br><span class="line">const auth = headers.get(&quot;Authorization&quot;);</span><br><span class="line">    const key = auth?.replace(&quot;Bearer &quot;, &quot;&quot;).trim();</span><br><span class="line">    if (!key || !VALID_API_KEYS.includes(key)) &#123;</span><br><span class="line">      return new Response(&quot;Unauthorized&quot;, &#123; status: 401 &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>还有2api不可或缺的伪造请求头了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const forwardHeaders: HeadersInit = &#123;</span><br><span class="line">  &quot;Content-Type&quot;: &quot;application/json&quot;,</span><br><span class="line">  &quot;User-Agent&quot;: &quot;Mozilla/5.0&quot;,</span><br><span class="line">  &quot;Origin&quot;: &quot;https://deepinfra.com&quot;,</span><br><span class="line">  &quot;Referer&quot;: &quot;https://deepinfra.com/&quot;,</span><br><span class="line">  &quot;x-deepinfra-source&quot;: &quot;web-embed&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后简单处理一下流式响应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const stream = new ReadableStream(&#123;</span><br><span class="line">  async start(controller) &#123;</span><br><span class="line">    const reader = response.body?.getReader();</span><br><span class="line">    const decoder = new TextDecoder();</span><br><span class="line"></span><br><span class="line">    while (reader) &#123;</span><br><span class="line">      const &#123; done, value &#125; = await reader.read();</span><br><span class="line">      if (done) break;</span><br><span class="line">      const chunk = decoder.decode(value);</span><br><span class="line">      for (const line of chunk.split(&quot;\n&quot;)) &#123;</span><br><span class="line">        if (line.startsWith(&quot;data: &quot;)) &#123;</span><br><span class="line">          const jsonText = line.slice(6);</span><br><span class="line">          if (jsonText === &quot;[DONE]&quot;) break;</span><br><span class="line">          try &#123;</span><br><span class="line">            const parsed = JSON.parse(jsonText);</span><br><span class="line">            const delta = parsed.choices[0].delta;</span><br><span class="line">            const reasoning = delta.reasoning_content ?? delta.content ?? &quot;&quot;;</span><br><span class="line">            const output = `data: $&#123;JSON.stringify(&#123; choices: [&#123; delta: &#123; content: reasoning &#125; &#125;] &#125;)&#125;\n\n`;</span><br><span class="line">            controller.enqueue(new TextEncoder().encode(output));</span><br><span class="line">          &#125; catch (_) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    controller.enqueue(new TextEncoder().encode(&quot;data: [DONE]\n\n&quot;));</span><br><span class="line">    controller.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>好啦！大功告成！该有的都有了，不该有的也有了（bushi）</p><p>接下来就是把它推到deno上运行了</p><p>如果您需要源码，请前往下面的链接获取。</p><p><a href="https://linux.do/t/topic/915152">[抛砖引玉]deepinfra2api，我人生中第一个2api - 开发调优 &#x2F; 开发调优, Lv2 - LINUX DO</a></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSA，被遗忘的官方安卓虚拟机</title>
      <link href="//post/45382.html"/>
      <url>//post/45382.html</url>
      
        <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><strong>写在前面</strong></h4><p>WSA，Windows的安卓子系统，作为Windows11宣传中的“直接打开安卓应用”的噱头。发布初期，存在很多bug与兼容问题。微软其实是有能力完善WSA的，但是被微软大刀部砍了（祖传艺能说是）。但是我个人认为，WSA还是一个非常好的安卓虚拟机。它具有较为安全，可靠。支持直接root，ADB调试，出厂自带谷歌三件套，与Windows生态的兼容性等等优点。接下来，我们来尝试在个人PC上安装WSA。</p><h4 id="安装前"><a href="#安装前" class="headerlink" title="安装前"></a><strong>安装前</strong></h4><h5 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a><strong>系统要求</strong></h5><p>若是Windows11，最低版本为21H2 Build 22000.526。</p><p>若是Windows10，最低版本为20H2 Build 10.0.19042.2604，推荐版本为22H2 Build 10.0.19045.2311，并且已经安装了编号为<a href="https://www.catalog.update.microsoft.com/Search.aspx?q=KB5014032">KB5014032</a>以及<a href="https://www.catalog.update.microsoft.com/Search.aspx?q=KB5022834">KB5022834</a>的系统补丁</p><p>其次，必须开启电脑的硬件虚拟化，否则无法运行</p><p>推荐开启的Windows服务：虚拟机平台（必须）、Windows 虚拟机监控程序平台（可选）、适用于 Linux 的 Windows 子系统（可选）、Hyper-V（可选）</p><p>注意：如果您之前安装过官方的WSA，则需要完全卸载</p><h5 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a><strong>硬件要求</strong></h5><p>内存最低8GB，推荐内存为16GB</p><p>确保C盘至少有10GB可用空间。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h4><p>前往<a href="https://github.com/A-JiuA/WSAOnWin10/releases">https://github.com/A-JiuA/WSAOnWin10/releases</a>下载您想要的版本。</p><p>注：MindTheGapps为自带谷歌应用商店，with-magisk为自带magisk，自行选择</p><p>下载到对应版本后，自行校对哈希值，校对完成后将压缩包解压，进入目录后运行Run.bat即可。</p><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a><strong>设置</strong></h4><p>*注：从这个仓库下载的所有版本均不带有系统桌面。各位请自行安装。</p><p>首先前往进阶设置，设置好所需内存与显卡。然后，<strong>开启开发者模式</strong>并且记住端口号。</p><p>由于没有系统桌面，且WSA采用虚拟磁盘，我们需要使用ADB进行文件管理、APK安装等活动。</p><p>推荐ADB工具：<a href="https://github.com/liangweihao/adb_tool">https://github.com/liangweihao/adb_tool</a></p><p>以这个工具为例，要在输入对方设备IP连接这一栏填写127.0.0.1:[端口号]</p><p>至此。一切已经结束。</p><h4 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a><strong>尾声</strong></h4><p>如后续需要更新版本，请前往WSA主设置面板，点击关闭Windows子系统Android™版。</p><p>然后彻底删除文件所在目录，重复上文你想要的版本的安装步骤即可</p><p>最后，enjoy🥰~</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抱脸部署FileCodeBox(database同步)</title>
      <link href="//post/26312.html"/>
      <url>//post/26312.html</url>
      
        <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/vastsa/FileCodeBox">https://github.com/vastsa/FileCodeBox</a></p><p>项目名称：FileCodeBox </p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>顾名思义，这个项目能够快速、高效地跨设备、跨网络链接实现文件、字符共享，可以自行设置过期时间&#x2F;次数。文件大小限制为20MB以内。</p><p>由于抱脸容器的特殊性（定时清空数据重启），我们需要设置database同步以达到不丢失数据。</p><h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>1.外网访问环境</p><p>2.一个huggingface账户</p><p>3.一点耐心</p><h4 id="必要环境变量"><a href="#必要环境变量" class="headerlink" title="必要环境变量"></a>必要环境变量</h4><p>1.huggingface自带的database服务仓库名</p><p>2.huggingface授权key</p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><h4 id="创建空间"><a href="#创建空间" class="headerlink" title="创建空间"></a>创建空间</h4><p>先前往space页面，单击New Space</p><p><img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image.png"></p><p>在space设置页面有几个需要填的东西</p><p>Space name：空间名称，决定域名部分（分配域名：用户名-空间名.hf.space）</p><p>Selet the Space SDK：选择Docker</p><p>Space harware：空间硬件配置，如果你不想多花冤枉钱就选择默认的free配置</p><p><img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image-uaia.png"></p><p>其他东西不用填，直接点击下方的Create Space</p><h4 id="存储库设置"><a href="#存储库设置" class="headerlink" title="存储库设置"></a>存储库设置</h4><p>点击个人头像，选择New Dataset<img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image-hdqa.png"></p><p>输入数据库名称，然后点击Create Dataset</p><p><img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image-wzeq.png"></p><p>这里的Datasets: xxxxx&#x2F;xxxxx将会作为DATASET_ID这个变量</p><p><img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image-ciqw.png"></p><h4 id="获取授权Key"><a href="#获取授权Key" class="headerlink" title="获取授权Key"></a>获取授权Key</h4><p>点击个人头像，前往Access Tokens 并输入密码进入</p><p><img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image-tkmw.png"></p><p>单击Creat new token</p><p>权限全部勾选（如果你懒得单独调）</p><p>创建后会返还以hf-xxxx开头的秘钥，这将作为HF_TOKEN这个变量使用。</p><h4 id="空间设置"><a href="#空间设置" class="headerlink" title="空间设置"></a>空间设置</h4><p>来到文件页面，选择README.md并在下方添加（如下图所示）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app_port: 12345</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image-bsdb.png"></p><p>然后转到Files选项卡，点击Add file并选择Create a new file</p><p>文件名为sync_data.sh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 检查环境变量</span><br><span class="line">if [ -z &quot;$HF_TOKEN&quot; ] || [ -z &quot;$DATASET_ID&quot; ]; then</span><br><span class="line">    echo &quot;Starting without backup functionality - missing HF_TOKEN or DATASET_ID&quot;</span><br><span class="line">    exec python main.py</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 登录HuggingFace (使用环境变量方式避免交互问题)</span><br><span class="line">export HUGGING_FACE_HUB_TOKEN=$HF_TOKEN</span><br><span class="line"></span><br><span class="line"># 同步函数</span><br><span class="line">sync_data() &#123;</span><br><span class="line">    while true; do</span><br><span class="line">        echo &quot;Starting sync process at $(date)&quot;</span><br><span class="line">  </span><br><span class="line">        # 创建临时压缩文件</span><br><span class="line">        cd /app</span><br><span class="line">        timestamp=$(date +%Y%m%d_%H%M%S)</span><br><span class="line">        backup_file=&quot;backup_$&#123;timestamp&#125;.tar.gz&quot;</span><br><span class="line">  </span><br><span class="line">        tar -czf &quot;/tmp/$&#123;backup_file&#125;&quot; data/</span><br><span class="line">  </span><br><span class="line">        python3 -c &quot;</span><br><span class="line">from huggingface_hub import HfApi</span><br><span class="line">import os</span><br><span class="line">def manage_backups(api, repo_id, max_files=2):</span><br><span class="line">    files = api.list_repo_files(repo_id=repo_id, repo_type=&#x27;dataset&#x27;)</span><br><span class="line">    backup_files = [f for f in files if f.startswith(&#x27;backup_&#x27;) and f.endswith(&#x27;.tar.gz&#x27;)]</span><br><span class="line">    backup_files.sort()</span><br><span class="line">  </span><br><span class="line">    if len(backup_files) &gt;= max_files:</span><br><span class="line">        files_to_delete = backup_files[:(len(backup_files) - max_files + 1)]</span><br><span class="line">        for file_to_delete in files_to_delete:</span><br><span class="line">            try:</span><br><span class="line">                api.delete_file(path_in_repo=file_to_delete, repo_id=repo_id, repo_type=&#x27;dataset&#x27;)</span><br><span class="line">                print(f&#x27;Deleted old backup: &#123;file_to_delete&#125;&#x27;)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                print(f&#x27;Error deleting &#123;file_to_delete&#125;: &#123;str(e)&#125;&#x27;)</span><br><span class="line">try:</span><br><span class="line">    api = HfApi()</span><br><span class="line">    api.upload_file(</span><br><span class="line">        path_or_fileobj=&#x27;/tmp/$&#123;backup_file&#125;&#x27;,</span><br><span class="line">        path_in_repo=&#x27;$&#123;backup_file&#125;&#x27;,</span><br><span class="line">        repo_id=&#x27;$&#123;DATASET_ID&#125;&#x27;,</span><br><span class="line">        repo_type=&#x27;dataset&#x27;</span><br><span class="line">    )</span><br><span class="line">    print(&#x27;Backup uploaded successfully&#x27;)</span><br><span class="line">  </span><br><span class="line">    manage_backups(api, &#x27;$&#123;DATASET_ID&#125;&#x27;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(f&#x27;Backup failed: &#123;str(e)&#125;&#x27;)</span><br><span class="line">&quot;</span><br><span class="line">        # 清理临时文件</span><br><span class="line">        rm -f &quot;/tmp/$&#123;backup_file&#125;&quot;</span><br><span class="line">  </span><br><span class="line">        # 设置同步间隔</span><br><span class="line">        SYNC_INTERVAL=$&#123;SYNC_INTERVAL:-72000&#125;</span><br><span class="line">        echo &quot;Next sync in $&#123;SYNC_INTERVAL&#125; seconds...&quot;</span><br><span class="line">        sleep $SYNC_INTERVAL</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 恢复函数</span><br><span class="line">restore_latest() &#123;</span><br><span class="line">    echo &quot;Attempting to restore latest backup...&quot;</span><br><span class="line">    python3 -c &quot;</span><br><span class="line">try:</span><br><span class="line">    from huggingface_hub import HfApi</span><br><span class="line">    import os</span><br><span class="line">  </span><br><span class="line">    api = HfApi()</span><br><span class="line">    files = api.list_repo_files(&#x27;$&#123;DATASET_ID&#125;&#x27;, repo_type=&#x27;dataset&#x27;)</span><br><span class="line">    backup_files = [f for f in files if f.startswith(&#x27;backup_&#x27;) and f.endswith(&#x27;.tar.gz&#x27;)]</span><br><span class="line">  </span><br><span class="line">    if backup_files:</span><br><span class="line">        latest = sorted(backup_files)[-1]</span><br><span class="line">        api.hf_hub_download(</span><br><span class="line">            repo_id=&#x27;$&#123;DATASET_ID&#125;&#x27;,</span><br><span class="line">            filename=latest,</span><br><span class="line">            repo_type=&#x27;dataset&#x27;,</span><br><span class="line">            local_dir=&#x27;/tmp&#x27;</span><br><span class="line">        )</span><br><span class="line">        os.system(f&#x27;tar -xzf /tmp/&#123;latest&#125; -C /app&#x27;)</span><br><span class="line">        os.remove(f&#x27;/tmp/&#123;latest&#125;&#x27;)</span><br><span class="line">        print(f&#x27;Restored from &#123;latest&#125;&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;No backup found&#x27;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(f&#x27;Restore failed: &#123;str(e)&#125;&#x27;)</span><br><span class="line">&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 主程序</span><br><span class="line">(</span><br><span class="line">    # 尝试恢复</span><br><span class="line">    restore_latest</span><br><span class="line">  </span><br><span class="line">    # 启动同步进程</span><br><span class="line">    sync_data &amp;</span><br><span class="line">  </span><br><span class="line">    # 启动主应用</span><br><span class="line">    exec python main.py</span><br><span class="line">) 2&gt;&amp;1 | tee -a /app/data/backup.log</span><br></pre></td></tr></table></figure><p>再次重复操作，文件名为Dockerfile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">FROM lanol/filecodebox:beta</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    python3-pip \</span><br><span class="line">    git \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">RUN pip3 install --no-cache-dir huggingface_hub datasets</span><br><span class="line"></span><br><span class="line">RUN useradd -m -u 1000 user</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">ENV HOME=/home/user \</span><br><span class="line">    PATH=/home/user/.local/bin:$PATH \</span><br><span class="line">    HF_HOME=/app/data/hf_cache \</span><br><span class="line">    PYTHONUNBUFFERED=1</span><br><span class="line"></span><br><span class="line">RUN mkdir -p /app/data &amp;&amp; \</span><br><span class="line">    chown -R user:user /app/data</span><br><span class="line"></span><br><span class="line">COPY sync_data.sh /app/</span><br><span class="line">RUN chmod +x /app/sync_data.sh &amp;&amp; \</span><br><span class="line">    chown user:user /app/sync_data.sh</span><br><span class="line"></span><br><span class="line">USER user</span><br><span class="line"></span><br><span class="line">EXPOSE 12345</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;/app/sync_data.sh&quot;]</span><br></pre></td></tr></table></figure><p>然后我们转到Setting选项卡，找到Variables and secrets</p><p>单击New Secret，并将下面的值键入</p><ul><li>DATASET_ID 存储库设置 步骤中的值，为用户名&#x2F;存储库ID</li><li>HF_TOKEN 获取授权Key 步骤中的值，为hf-xxxxxxxx格式</li><li>SYNC_INTERVAL 备份间隔时间，以秒为单位，推荐3600</li></ul><p>然后我们的项目就可以顺利的跑起来了</p>]]></content>
      
      
      <categories>
          
          <category> Huggingface </category>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Huggingface </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
