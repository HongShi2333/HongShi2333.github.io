<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WRC类游戏该怎么买，怎么玩？</title>
      <link href="//post/5975.html"/>
      <url>//post/5975.html</url>
      
        <content type="html"><![CDATA[<p>众所周知，拉力赛这一类别出过很多游戏，有KT系列的WRC5到WRC世代，有EA SPORT的EA WRC，还有像是art if rally一类的类模拟拉力游戏。但是这些游戏往往没有什么像样的新手教程，也很少有人做相关的东西，使得很多人根本玩不完这个游戏，体验很差。为了让你那七块到三百块大洋不白花，我我决定写一篇文档，帮助你更快入门拟真&#x2F;半拟真拉力游戏</p><h2 id="受众群体"><a href="#受众群体" class="headerlink" title="受众群体"></a>受众群体</h2><p>我们的钱都不是大风刮来的（如果有，请送我一点，谢谢），我们在买之前可以先了解一下这类游戏的受众。<br>如果你是抱着碎片化时间游玩、期望短期投入就能获得大量回报的心态去玩，我建议最好马上退款，抱着这种心态只会让你越玩越红温，当你关了游戏想退款的时候往往已经超过退款小时数了（）<br>拟真&#x2F;半拟真的受众群体其实比较小，拉力赛系列的核心玩法就是刷圈。赛道设计基本上都是多弯、路面多种路况、狭窄、恶劣天气为主，且对玩家的微操、熟练度等要求较高，并且你还要分一些心用来听路书。如果做不到这些，可以考虑NFS&#x2F;地平线系列的娱乐类赛车游戏</p><h2 id="初次游玩"><a href="#初次游玩" class="headerlink" title="初次游玩"></a>初次游玩</h2><p>本表格为个人建议，带有较为强烈的主观性，仅供参考。<br>从上到下为初次游玩、了解过一些竞速游戏、竞速游戏老手。</p><table><thead><tr><th>辅助方面</th><th>车辆选择</th><th>地图选择</th></tr></thead><tbody><tr><td>辅助全开，包括自动换挡</td><td>选择前驱、底马力车辆（青年组）</td><td>多选择荷兰、意大利恶魔岛一类简单地图</td></tr><tr><td>可以尝试关闭TC&#x2F;ABS，切换为手动挡</td><td>尝试更高组别，四驱、高马力车辆（2组&#x2F;1组）</td><td>可以尝试蒙特卡洛、意大利等多弯、狭窄、路况复杂的地图</td></tr><tr><td>可以尝试将辅助全部关闭</td><td>直接尝试1组、奖杯车辆等</td><td>可以尝试芬兰、墨西哥等高难度地图</td></tr></tbody></table><p>我这里以WRC9为例，给各位提一些建议。</p><h3 id="外设-环境等乱七八糟的"><a href="#外设-环境等乱七八糟的" class="headerlink" title="外设&#x2F;环境等乱七八糟的"></a>外设&#x2F;环境等乱七八糟的</h3><p>我个人建议使用手柄、方向盘等外设进行游玩，毕竟键盘还是太难评了（也不是说键盘出不了好成绩，我就在恶魔岛开着1组福特嘉年华做出了1分57秒233的圈速）<br>其次，每次游玩最好安排半个小时以上，并且每隔半个小时起来活动一下，避免变成有痔青年。</p><h3 id="规则讲解"><a href="#规则讲解" class="headerlink" title="规则讲解"></a>规则讲解</h3><p>WRC并不是所有人一起发车，比谁先到终点的赛事，而是车手间隔发车，比拼谁的用时最短。<br>如果你在起步前五秒倒计时内起步，就会判定为抢跑，罚时5s（注意，拟真类游戏任何一毫秒都至关重要！请千万不要吃到罚时）<br>中途开出赛道，游戏会在左侧给出偏离赛道提示，并且伴有倒计时，请在倒计时内回到赛道范围，否则会强制重置车辆，并且吃到罚时（5-10s不等）<br>此外，也不要去创人，WRC的人可不是摆设，碰撞之后直接一个重置+罚时，大部分为9s。</p><h3 id="试车"><a href="#试车" class="headerlink" title="试车"></a>试车</h3><p>首先我建议不要直接开始比赛，先到测试区开一局<br>选择你觉得顺眼的车，进入测试区。<br>请按下你的油门，在柏油、土路、泥泞路段等地形驾驶，感受车辆的反馈，并且尝试长时间高速行驶且不发生事故，就说明这辆车挺合适的（注意，你可以在设置页面切换悬挂、轮胎配方、变速箱等部件的配置）。<br>如果你认为你准备好了，可以试着开一局正赛。<br>此外，你也可以前往赛车驾校来参与不同路面路况的模拟练习。</p><h3 id="正赛流程"><a href="#正赛流程" class="headerlink" title="正赛流程"></a>正赛流程</h3><p>可以前往快速比赛来设置赛道、车辆、天气等条件，完成后即可开始游戏。<br>一般一场比赛的时间为3-20分钟不等,请做好心理准备。<br>开始比赛时，会有5秒倒计时，如果你想要起步更快，可以尝试关闭起步辅助，按住手刹，将油门按下，保持发动机转速，在go显示的时候松开手刹，尽量减少车辆起步时的打滑。<br>比赛过程中，你会遇到很多复杂的路况，包括但不限于过水、飞跳、不确定飞跳、道路变窄、、隧道、急转弯等。并且本游戏没有小地图，你能得知前方路面状况的只有路书，所以，请认真听、看路书播报。<br>每次经过计时点时，都会显示您这个赛段的所用时间，您与第一名的差距（如果你不是第一位起步的话）。<br>另外，请注意左下角的车损情况，如果您的赛车损坏太过严重，可能会被退赛。<br>冲过终点线，会显示时间、排名、时间差距等信息。</p><h2 id="更加深入"><a href="#更加深入" class="headerlink" title="更加深入"></a>更加深入</h2><p>您可以尝试在测试区调整车辆的数据，调教悬挂、变速箱等部件，获得更适合你的驾驶配置。<br>这里不进行详细描述，毕竟我也不会调车（）</p><h2 id="附加内容"><a href="#附加内容" class="headerlink" title="附加内容"></a>附加内容</h2><p>生涯模式：你需要从青年组车手做起，维护与厂商之间的关系、做好资金规划、日程规划、车队管理，并在正赛中取得名次，一步一步晋升到更高级的组别。（人话：车队老板兼车手，啥事儿都由你负责）<br>每日&#x2F;周挑战：随机地图、车辆，可能伴随车辆损坏，你需要在这些条件下做出最快圈速，与全球玩家同台竞技，共同比拼。<br>联机：叫上两三个人来一场别样的拉力车大赛（）当然，你也可以让他做你的领航员（不建议，容易红温，成全熟土豆）<br>等等<br>好啦！以上就是我个人关于如何购买、游玩拉力赛游戏的个人建议，希望能给各位一点点帮助。</p><p>本文同步发布于[<a href="https://linux.do/t/topic/1059118">破界] WRC类游戏到底该怎么买，怎么玩？ - 搞七捻三 - LINUX DO</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Venice逆向思路+过程</title>
      <link href="//post/56354.html"/>
      <url>//post/56354.html</url>
      
        <content type="html"><![CDATA[<p>今天下午看了看，之前的dolphin对话似乎已经似了，不太甘心，就继续上网扒拉，找到一个看着<a href="https://venice.ai/">挺靠谱的站</a>（他们家收录的dolphin的模型）而且我一看，你似乎也没有道德审查啊，那很好了，直接开逆。</p><h3 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h3><p>1.我打算用deno写，毕竟那玩意好写（）<br>2.转发请求到venice，并且返回结果搞成OpenAI标准格式，并且支持流式响应<br>3.增加一个API KEY，别是个东西就能刷</p><h3 id="开写！"><a href="#开写！" class="headerlink" title="开写！"></a>开写！</h3><h4 id="API鉴权"><a href="#API鉴权" class="headerlink" title="API鉴权"></a>API鉴权</h4><p>首先搞定API鉴权，这没啥好说的，在请求头中检查 Authorization 字段，要求格式为 Bearer key，缺失或者不对直接一个401糊脸。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">validateApiKey</span>(<span class="params">req: Request</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> authHeader = req.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!authHeader) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> match = authHeader.<span class="title function_">match</span>(<span class="regexp">/^Bearer\s+(.+)$/</span>);</span><br><span class="line">  <span class="keyword">if</span> (!match) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> match[<span class="number">1</span>] === <span class="variable constant_">API_KEY</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模型列表接口"><a href="#模型列表接口" class="headerlink" title="模型列表接口"></a>模型列表接口</h4><p>然后又到了喜闻乐见的&#x2F;v1&#x2F;models环节，目前这个站只有俩模型，就直接写死在代码里了，后面改再加（）还是喜闻乐见的OpenAI格式。返回一个固定的 JSON，列出可用模型。包含id、object、created等字段。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">openaiModels</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">object</span>: <span class="string">&quot;list&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">&quot;dolphin-3.0-mistral-24b-1dot1&quot;</span>, <span class="attr">object</span>: <span class="string">&quot;model&quot;</span>, ... &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="string">&quot;mistral-31-24b&quot;</span>, <span class="attr">object</span>: <span class="string">&quot;model&quot;</span>, ... &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="chat接口"><a href="#chat接口" class="headerlink" title="chat接口"></a>chat接口</h4><p>接下来是重中之重，聊天接口：&#x2F;v1&#x2F;chat&#x2F;completions<br>需求：接收用户传入的 messages、model、temperature 等参数。转换为 Venice.ai 的请求格式（prompt、modelId 等）。发起请求并获取响应。<br>这个有两种模式：流式和非流</p><p>非流式：一次性拼接所有返回内容，组装成 OpenAI 的 chat.completion 格式。</p><p>流式：逐行读取 Venice.ai 的输出，每行 JSON 解析后立即转发为 SSE 格式的 data: {…}，模拟 OpenAI 的流式输出。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stream) &#123;</span><br><span class="line">  <span class="comment">// 读取 Venice.ai 的响应流</span></span><br><span class="line">  <span class="comment">// 每解析到一行 JSON，就转成 OpenAI 的 chunk 格式推送</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 收集所有行，拼接成完整回答</span></span><br><span class="line">  <span class="comment">// 返回标准的 chat.completion JSON</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接启动服务，声明一下路径就行了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">serve</span>(<span class="keyword">async</span> (<span class="attr">req</span>: <span class="title class_">Request</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="keyword">new</span> <span class="title function_">URL</span>(req.<span class="property">url</span>);</span><br><span class="line">  <span class="keyword">if</span> (url.<span class="property">pathname</span> === <span class="string">&quot;/v1/models&quot;</span>) &#123; ... &#125;</span><br><span class="line">  <span class="keyword">if</span> (url.<span class="property">pathname</span> === <span class="string">&quot;/v1/chat/completions&quot;</span>) &#123; ... &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="string">&quot;Not Found&quot;</span>, &#123; <span class="attr">status</span>: <span class="number">404</span> &#125;);</span><br><span class="line">&#125;, &#123; <span class="attr">port</span>: <span class="number">8000</span> &#125;);</span><br></pre></td></tr></table></figure><p>大功告成！接下来愉快地去刷你的API去吧！</p><p>完整代码前往<a href="https://linux.do/t/topic/1013607">Venice2api逆向思路(附代码)（这个模型没有道德审查哦~） - 开发调优 &#x2F; 开发调优, Lv2 - LINUX DO</a>获取</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大善人发力，无限worker</title>
      <link href="//post/21570.html"/>
      <url>//post/21570.html</url>
      
        <content type="html"><![CDATA[<p>我们亲爱的赛博大善人近几天又带来了新的服务：Snippets，让我们简单了解一下</p><h3 id="这是啥？"><a href="#这是啥？" class="headerlink" title="这是啥？"></a>这是啥？</h3><p>这个玩意官方的定义是：<strong>短而强大的 JavaScript 片段，可动态定制您的网站或应用程序。</strong><a href="https://developers.cloudflare.com/rules/snippets/">官方文档</a><br>简而言之，就是一个不限每日调用次数的js片段，也就是大善人提供的worker服务。</p><h3 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h3><p>首先，你需要在大善人那里托管一个域名，并且域名处于活跃状态，然后我们需要前往域名详情→规则→Snippets。如果你用的是一些免费域名（<a href="http://如qzz.io/">如qzz.io</a>、dpdns.org等）是需要绑定信用卡的，但是如果你是付费域&#x2F;特殊免费域（<a href="http://如ggff.net/">如ggff.net</a>）就可以直接进入详情页了。<br>进入详情页后，就可以新建代码片段，托管你的代码了。<br>注意，这里与worker的步骤稍有不同，默认情况下snippets是不会给你分配域名的，所以必须绑定自定义域，其实在你点击部署的时候就会弹出一个<strong>自定义筛选表达式</strong>的框，我这里建议是这样填写（我是一个纯纯的小白，这个方法可能很白痴，各位大佬请轻喷）主机名 等于 [你想要的前缀].[你的域名]。点击完成后大概率会有一个窗口，告诉你<strong>此规则可能不适用于你的流量</strong>，这个时候可以直接选择<strong>创建代理DNS记录</strong>，记录类型为A，名称不用管，IPV4地址填写下面给出的放弃请求的地址（大部分为192.0.2.1）点一下保存记录就行了（tips：这个记录基本上是立即生效的哦）</p><h3 id="那么，缺点是什么呢？"><a href="#那么，缺点是什么呢？" class="headerlink" title="那么，缺点是什么呢？"></a>那么，缺点是什么呢？</h3><p>第一，这个服务并不面向所有域名开放，大部分免费域名都被排除在外了<br>第二，这个服务一个域名有且仅有5个snippets位置，多了不行。<br>第三，不能像worker一样方便地设置环境变量、更换部署版本，环境变量仅能写死在代码中。<br>第四，勒克莱尔（千年勒老四）</p><p>发布于[<a href="https://linux.do/t/topic/1011644">短短短文]大善人再次发力，无限worker - 开发调优 &#x2F; 开发调优, Lv1 - LINUX DO</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 部署 </category>
          
          <category> CloudFlare </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 部署 </tag>
            
            <tag> CloudFlare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[折腾笔记]小狼毫输入法</title>
      <link href="//post/61849.html"/>
      <url>//post/61849.html</url>
      
        <content type="html"><![CDATA[<p>之前一直在用搜狗，但是搜狗最近越来越不好用了，各种广告AI满天飞，有的时候后台占用比Edge还大，就离谱。所以我就去网上搜索开源的轻量输入法，就找到了小狼毫</p><h3 id="基础安装"><a href="#基础安装" class="headerlink" title="基础安装"></a>基础安装</h3><p>首先前往<a href="https://rime.im/">这里</a>去下载一个合适的版本，然后一路安装（如果不想后期太麻烦我建议选择默认用户文件夹📁）</p><p>安装完成后直接用还是稍微有点难用的，暂且不说让人感到爆炸的默认UI，难用的输入联想，令人感到不安的配置文档。光快捷键就很让人不舒服了。所以我们得进行一些小小的个性化设置</p><h3 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h3><p>Tips:更多相关项目可以前往<a href="https://github.com/rime">RIME</a>查看</p><h4 id="安装雾凇拼音包"><a href="#安装雾凇拼音包" class="headerlink" title="安装雾凇拼音包"></a>安装雾凇拼音包</h4><p>首先前往<a href="https://github.com/iDvel/rime-ice">iDvel&#x2F;rime-ice: Rime 配置：雾凇拼音 | 长期维护的简体词库</a>将整个项目打包下载，然后将目前的输入法设置为小狼毫，右键小狼毫旁的“中”字图标，选择“用户文件夹”<br><img src="https://raw.githubusercontent.com/HongShi211/blog/main/Qexo/25/10/xlh01_cef4a7efb2623e33baa5a6e1c383e742.jpg" alt="01"></p><p>我们需要将下载到的压缩包直接解压到用户文件夹中，完成后再次右击小狼毫旁的“中”字图标，选择“重新部署”稍等片刻后就加载完成了。但是此时还没有切换到我们安装的拼音包，我们需要右击小狼毫旁的“中”字图标，选择“输入法设定”，在弹出窗口中勾选雾凇拼音，并点击河南按钮（中，bushi）即可。完成后，我们需要按住键盘上的Ctrl+~，选择雾凇拼音，即可完成拼音设置。</p><h4 id="自定义输入法主题"><a href="#自定义输入法主题" class="headerlink" title="自定义输入法主题"></a>自定义输入法主题</h4><p>我个人推荐使用两个工具。</p><p>第一个是可视化配置程序：<a href="https://github.com/qzly/RimeControl">qzly&#x2F;RimeControl</a></p><p>第二个是在线调整一些功能的github pages：<a href="https://pdog18.github.io/rime-soak/">润笔</a></p><p>这是他的仓库（现已不再维护）：<a href="https://github.com/pdog18/rime-soak">pdog18&#x2F;rime-soak: Rime 设置助手</a></p><p>有了这两个工具，我们就可以告别那些恼人的yml配置文档了</p><h4 id="导入搜狗词库"><a href="#导入搜狗词库" class="headerlink" title="导入搜狗词库"></a>导入搜狗词库</h4><p>不得不说，搜狗在词库方面还是很权威的，为了使用体验更好一点，我建议各位可以导入搜狗的词库。</p><p>我们需要一个小工具，可以去<a href="https://github.com/studyzy/imewlconverter">studyzy&#x2F;imewlconverter</a>下载</p><p>我们先获取我们之前一直用的搜狗的个人词库，来到搜狗输入法的设置页面，选择词库，导出&#x2F;备份，得到一份bin文件。如果你想要补充，可以前往<a href="https://pinyin.sogou.com/dict/">搜狗细胞词库_词库下载_词典_输入法字典</a>这里下载想要的词库，下载完成后打开我们的词库转换器，把所有你要的词库文件都拖进去，此时深蓝词库转换会自动识别输入格式，我们仅需要把输出设置为Rime中州韵即可。出现弹窗选择自己的操作系统，将文件取名并保存到一个你能找到的地方，然后，你需要新建一个名为<strong>sogou_supplement.dict.yaml</strong>的文件，文件前几行为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Rime dictionary</span><br><span class="line"># encoding: utf-8</span><br><span class="line">---</span><br><span class="line">name: sogou_supplement</span><br><span class="line">version: &quot;2025.10.02&quot;</span><br><span class="line">sort: by_weight</span><br><span class="line">use_preset_vocabulary: false</span><br><span class="line">import_tables: []</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接下来打开转换的文件，将所有内容复制到…的下一行，我们的词库已经准本好了，就剩下导入了。</p><p>接下来，我们要去到用户文件夹，找到一个名为default.custom.yaml的文件，在path下增加几行代码（如下，注意缩进！！！！）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">patch:</span><br><span class="line">  &quot;*/translator/import_tables/+&quot;:</span><br><span class="line">    - sogou_supplement</span><br></pre></td></tr></table></figure><p>如果需要更新，直接找到创建的<strong>sogou_supplement.dict.yaml</strong>文件，在后面追加就行了。</p><h4 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h4><p>但是这两个工具还不太很够，有些人（比如我）就喜欢有一些自定义的快捷键，比如⬅️➡️切换候选字，[]翻页，按shift切到英文且保留候选栏字符等。这些都可以通过用户文件夹中的yml配置文件来实现，下面是一些比较常见的快捷键设置。</p><p>（以下均在 <code>%AppData%\Rime\*.custom.yaml</code> 里完成，改完右键托盘图标 → 重新部署即可生效）</p><ol><li>中英文快速切换</li><li>简繁体一键切换</li><li>翻页 &#x2F; 删除用户词 &#x2F; 临时英文模式等效率键</li></ol><p>下面给出「最小可运行」示例，复制即可用；如需更多按键，在同类节点下继续追加即可。</p><ol><li><p>中英文切换（左 Shift 直接切，右 Shift 当「临时大写」用就松手回中文）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 文件：default.custom.yaml</span><br><span class="line">patch:</span><br><span class="line">  key_binder:</span><br><span class="line">    bindings:</span><br><span class="line">      # 单击左 Shift → 切到英文</span><br><span class="line">      - &#123; when: always, accept: Shift_L, toggle: ascii_mode &#125;</span><br><span class="line">      # 右 Shift 仅临时大写，松手即回中文（already default，写这里方便你改）</span><br><span class="line">      - &#123; when: composing, accept: Shift_R, send: Escape &#125;</span><br></pre></td></tr></table></figure></li><li><p>简繁体一键切换（例：Ctrl + Shift + F）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 文件：default.custom.yaml</span><br><span class="line">patch:</span><br><span class="line">  key_binder:</span><br><span class="line">    bindings:</span><br><span class="line">      # 注意 toggle 名要与 schema 里 switches 节点保持一致</span><br><span class="line">      - &#123; when: always, accept: &quot;Control+Shift+F&quot;, toggle: zh_trad &#125;</span><br></pre></td></tr></table></figure></li><li><p>候选词翻页（习惯 ,&#x2F;. 或 –&#x2F;&#x3D; 均可）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">patch:</span><br><span class="line">  key_binder:</span><br><span class="line">    bindings:</span><br><span class="line">      - &#123; when: has_menu, accept: comma, send: Page_Up &#125;</span><br><span class="line">      - &#123; when: has_menu, accept: period, send: Page_Down &#125;</span><br></pre></td></tr></table></figure></li><li><p>删除误上屏的用户词（立即后悔键）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patch:</span><br><span class="line">  key_binder:</span><br><span class="line">    bindings:</span><br><span class="line">      - &#123; when: has_menu, accept: Control+Delete, send: unpublish_candidate &#125;</span><br></pre></td></tr></table></figure><p>下面是修改流程</p><ol><li>打开用户目录<br>托盘图标右键 → 「用户文件夹」即可进入 <code>%AppData%\Rime</code>。</li><li>新建 &#x2F; 编辑 <code>default.custom.yaml</code>（没有就新建，已有就追加 <code>patch:</code> 节点）。</li><li>保存后仍右键托盘 → 「重新部署」；看到状态栏提示「部署完成」即可测试新键。</li></ol></li></ol><h3 id="系统默认输入法设置"><a href="#系统默认输入法设置" class="headerlink" title="系统默认输入法设置"></a>系统默认输入法设置</h3><p>目前属于你的输入法已经配置完了，接下来就是使用了，我们只需要在Windows设置-&gt;时间和语言-&gt;语言-&gt;键盘-&gt;替代默认输入法改为小狼毫即可。</p><p>大功告成！去享受这个轻量美丽的输入法吧！</p>]]></content>
      
      
      <categories>
          
          <category> 折腾笔记 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折腾笔记 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dolphin逆向思路+过程</title>
      <link href="//post/42496.html"/>
      <url>//post/42496.html</url>
      
        <content type="html"><![CDATA[<p>十一到处逛，在L站发现了个帖子<a href="https://linux.do/t/topic/1002906">发现一个AI（可免费使用） - 开发调优 - LINUX DO</a>我注意到有些站点并没有严格的鉴权限制，甚至允许未登录的用户直接调用模型接口。这类接口往往隐藏在浏览器的网络请求中，通过分析可以实现标准化调用，从而兼容 OpenAI 的 API 生态。下面记录一下我对 <strong>Dolphin 模型接口</strong> 的逆向过程与思路。</p><h4 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h4><p>目标网站提供了一个在线对话页面，前端直接与模型服务交互：</p><ul><li>请求地址：<code>https://chat.dphn.ai/api/chat</code></li><li>请求方法：<code>POST</code></li><li>返回格式：<code>text/event-stream</code>（SSE 流式返回）</li></ul><p>这里的关键点是 <strong>数据并不是普通 JSON，而是通过 SSE 逐条传输</strong>，这意味着需要模拟流式读取。</p><h4 id="观察请求参数"><a href="#观察请求参数" class="headerlink" title="观察请求参数"></a>观察请求参数</h4><p>通过浏览器开发者工具（Network 面板），我们可以看到完整的请求：</p><ul><li><code>Content-Type: application/json</code></li><li><code>Accept: text/event-stream</code></li><li>请求体包含：<ul><li><code>messages</code>（聊天上下文，符合 OpenAI 格式）</li><li><code>model</code>（例如 <code>dolphinpod:24B</code>）</li><li><code>template</code>（推理模式，如 <code>&quot;logical&quot;</code>）</li></ul></li></ul><blockquote><p>📌 这一步确认了接口 <strong>几乎与 OpenAI Chat API 一致</strong>，只是多了一个 <code>template</code> 字段。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;messages&quot;: [</span><br><span class="line">    &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你是谁？&quot;&#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;model&quot;: &quot;dolphinpod:24B&quot;,</span><br><span class="line">  &quot;template&quot;: &quot;logical&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="处理-SSE-流式返回"><a href="#处理-SSE-流式返回" class="headerlink" title="处理 SSE 流式返回"></a>处理 SSE 流式返回</h4><p>返回的数据不是一次性 JSON，而是 <strong>逐行推送的 SSE</strong>。每一行类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;&quot;choices&quot;:[&#123;&quot;delta&quot;:&#123;&quot;content&quot;:&quot;你好&quot;&#125;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>需要在客户端逐行解析，提取 <code>delta.content</code> 并拼接成最终结果。<br>这与 OpenAI <code>stream=True</code> 的机制完全一致。</p><h4 id="构建代理层思路"><a href="#构建代理层思路" class="headerlink" title="构建代理层思路"></a>构建代理层思路</h4><p>由于原始接口并没有统一的 API Key 验证机制，如果想要对外安全暴露，需要自己加一层 <strong>代理服务</strong>：</p><ol><li><strong>转发请求</strong>：<ul><li>外部调用 <code>/v1/chat/completions</code></li><li>代理服务转发到 <code>https://chat.dphn.ai/api/chat</code></li></ul></li><li><strong>兼容 OpenAI 格式</strong>：<ul><li>输入&#x2F;输出保持与 OpenAI SDK 一致</li><li>方便用户直接用 <code>openai.ChatCompletion.create()</code> 调用</li></ul></li><li><strong>自定义鉴权</strong>：<ul><li>在代理层添加 API Key 校验</li><li>保证只有授权用户可以访问</li></ul></li></ol><h4 id="关键难点与解决思路"><a href="#关键难点与解决思路" class="headerlink" title="关键难点与解决思路"></a>关键难点与解决思路</h4><ul><li><strong>SSE 转发</strong><ul><li>不能直接 <code>resp.json()</code>，必须逐行解析</li><li>需要在服务端用 <code>StreamingResponse</code>（Python）或 <code>ReadableStream</code>（Deno）转发</li></ul></li><li><strong>浏览器伪装</strong><ul><li>有些站点可能检查 <code>Origin</code> 和 <code>Referer</code></li><li>需要在请求头中补全这两个字段</li></ul></li><li><strong>模型列表</strong><ul><li>原站点没有 <code>/v1/models</code> 接口</li><li>可以在代理层手动定义可用模型（如 <code>dolphinpod:24B</code>）</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>整个逆向过程的关键是：</p><ol><li><strong>观察请求</strong> → 确认接口是 <code>/api/chat</code>，参数与 OpenAI 格式类似</li><li><strong>理解响应</strong> → 识别是 SSE 流式输出，逐行解析</li><li><strong>设计代理</strong> → 实现 <code>/v1/chat/completions</code> 与 <code>/v1/models</code>，加上 API Key 保护</li><li><strong>统一调用</strong> → 让外部可以直接用 OpenAI SDK 访问 Dolphin 模型</li></ol><p>通过这种方式，任何支持 OpenAI API 的工具（如 LangChain、ChatUI）都可以无缝切换到 Dolphin 模型。</p><p>行了，完事儿了</p><p>完整代码前往：<a href="https://linux.do/t/topic/1003204">dolphin2api-我写的第二个2api - 开发调优 &#x2F; 开发调优, Lv2 - LINUX DO</a></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deepinfra逆向思路+过程</title>
      <link href="//post/62072.html"/>
      <url>//post/62072.html</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前几天在网上冲浪的时候发现一个网站，叫<a href="https://deepinfra.com/">Deepinfra</a>，点击去发现是一个AI的网站，有意思的是网站首页有一个对话页面，这个页面似乎是可以直接调用站内AI的，而且没有次数、内容限制。</p><p>于是我就打开F12，发了条消息打算抓一下然后有意思的就来了。<img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image-TLck.png"></p><p>这个comletions直接请求<a href="https://api.deepinfra.com/v1/openai/chat/completions">https://api.deepinfra.com/v1/openai/chat/completions</a> ，这个地址与OpenAI的标准格式有一些差距，而且我找了一大圈都没找到cookie或者别的用于鉴权的东西，似乎它前端没有做鉴权，我试着在python中把调用地址填好，编了一个key，居然调用成功了，还是流式的</p><p>那么事情很有意思了，其实到这一步就已经可以了，能直接去填一下模型名直接去用。但是我想要把它接入到我的API站里，那么我就要做点多余的事了。</p><p>目标：标准OpenAI格式调用，能通过&#x2F;v1&#x2F;models获取模型列表，自定义API KEY限制请求。</p><p>首先这个项目的基调已经定下了，是2api，那么我们就需要选一个合适的语言，方便部署的同时也要足够优雅，我选择了用Deno去写。</p><h4 id="开写！"><a href="#开写！" class="headerlink" title="开写！"></a>开写！</h4><p>首先要获取模型列表，我原本打算照着请求一个个去薅，但是我突然发现他们有官方的API文档，就直接进去了，里面有首页能调用的模型，就直接copy过来用了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const SUPPORTED_MODELS = [</span><br><span class="line">  &#123; id: &quot;openai/gpt-oss-120b&quot;, object: &quot;model&quot; &#125;,</span><br><span class="line">  &#123; id: &quot;moonshotai/Kimi-K2-Instruct&quot;, object: &quot;model&quot; &#125;,</span><br><span class="line">  &#123; id: &quot;zai-org/GLM-4.5&quot;, object: &quot;model&quot; &#125;,</span><br><span class="line">  &#123; id: &quot;Qwen/Qwen3-Coder-480B-A35B-Instruct-Turbo&quot;, object: &quot;model&quot; &#125;,</span><br><span class="line">  &#123; id: &quot;deepseek-ai/DeepSeek-R1-0528-Turbo&quot;, object: &quot;model&quot; &#125;,</span><br><span class="line">  &#123; id: &quot;deepseek-ai/DeepSeek-V3-0324-Turbo&quot;, object: &quot;model&quot; &#125;,</span><br><span class="line">  &#123; id: &quot;meta-llama/Llama-4-Maverick-17B-128E-Instruct-Turbo&quot;, object: &quot;model&quot; &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>模型列表搞定之后，就该整一下模型列表和completions接口了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">serve(async (req: Request) =&gt; &#123;</span><br><span class="line">  const url = new URL(req.url);</span><br><span class="line"></span><br><span class="line">  if (req.method === &quot;GET&quot; &amp;&amp; url.pathname === &quot;/v1/models&quot;) &#123;</span><br><span class="line">    return new Response(JSON.stringify(&#123;</span><br><span class="line">      object: &quot;list&quot;,</span><br><span class="line">      data: SUPPORTED_MODELS</span><br><span class="line">    &#125;), &#123;</span><br><span class="line">      status: 200,</span><br><span class="line">      headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (req.method === &quot;POST&quot; &amp;&amp; url.pathname === &quot;/v1/chat/completions&quot;) &#123;</span><br><span class="line">    const body = await req.text();</span><br><span class="line">    const headers = new Headers(req.headers);</span><br></pre></td></tr></table></figure><p>完事儿还有自定义key，不能是个东西就过来刷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const VALID_API_KEYS = [&quot;sk-1&quot;, &quot;sk-2&quot;];</span><br><span class="line">const auth = headers.get(&quot;Authorization&quot;);</span><br><span class="line">    const key = auth?.replace(&quot;Bearer &quot;, &quot;&quot;).trim();</span><br><span class="line">    if (!key || !VALID_API_KEYS.includes(key)) &#123;</span><br><span class="line">      return new Response(&quot;Unauthorized&quot;, &#123; status: 401 &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>还有2api不可或缺的伪造请求头了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const forwardHeaders: HeadersInit = &#123;</span><br><span class="line">  &quot;Content-Type&quot;: &quot;application/json&quot;,</span><br><span class="line">  &quot;User-Agent&quot;: &quot;Mozilla/5.0&quot;,</span><br><span class="line">  &quot;Origin&quot;: &quot;https://deepinfra.com&quot;,</span><br><span class="line">  &quot;Referer&quot;: &quot;https://deepinfra.com/&quot;,</span><br><span class="line">  &quot;x-deepinfra-source&quot;: &quot;web-embed&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后简单处理一下流式响应</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const stream = new ReadableStream(&#123;</span><br><span class="line">  async start(controller) &#123;</span><br><span class="line">    const reader = response.body?.getReader();</span><br><span class="line">    const decoder = new TextDecoder();</span><br><span class="line"></span><br><span class="line">    while (reader) &#123;</span><br><span class="line">      const &#123; done, value &#125; = await reader.read();</span><br><span class="line">      if (done) break;</span><br><span class="line">      const chunk = decoder.decode(value);</span><br><span class="line">      for (const line of chunk.split(&quot;\n&quot;)) &#123;</span><br><span class="line">        if (line.startsWith(&quot;data: &quot;)) &#123;</span><br><span class="line">          const jsonText = line.slice(6);</span><br><span class="line">          if (jsonText === &quot;[DONE]&quot;) break;</span><br><span class="line">          try &#123;</span><br><span class="line">            const parsed = JSON.parse(jsonText);</span><br><span class="line">            const delta = parsed.choices[0].delta;</span><br><span class="line">            const reasoning = delta.reasoning_content ?? delta.content ?? &quot;&quot;;</span><br><span class="line">            const output = `data: $&#123;JSON.stringify(&#123; choices: [&#123; delta: &#123; content: reasoning &#125; &#125;] &#125;)&#125;\n\n`;</span><br><span class="line">            controller.enqueue(new TextEncoder().encode(output));</span><br><span class="line">          &#125; catch (_) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    controller.enqueue(new TextEncoder().encode(&quot;data: [DONE]\n\n&quot;));</span><br><span class="line">    controller.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>好啦！大功告成！该有的都有了，不该有的也有了（bushi）</p><p>接下来就是把它推到deno上运行了</p><p>如果您需要源码，请前往下面的链接获取。</p><p><a href="https://linux.do/t/topic/915152">[抛砖引玉]deepinfra2api，我人生中第一个2api - 开发调优 &#x2F; 开发调优, Lv2 - LINUX DO</a></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSA，被遗忘的官方安卓虚拟机</title>
      <link href="//post/45382.html"/>
      <url>//post/45382.html</url>
      
        <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><strong>写在前面</strong></h4><p>WSA，Windows的安卓子系统，作为Windows11宣传中的“直接打开安卓应用”的噱头。发布初期，存在很多bug与兼容问题。微软其实是有能力完善WSA的，但是被微软大刀部砍了（祖传艺能说是）。但是我个人认为，WSA还是一个非常好的安卓虚拟机。它具有较为安全，可靠。支持直接root，ADB调试，出厂自带谷歌三件套，与Windows生态的兼容性等等优点。接下来，我们来尝试在个人PC上安装WSA。</p><h4 id="安装前"><a href="#安装前" class="headerlink" title="安装前"></a><strong>安装前</strong></h4><h5 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a><strong>系统要求</strong></h5><p>若是Windows11，最低版本为21H2 Build 22000.526。</p><p>若是Windows10，最低版本为20H2 Build 10.0.19042.2604，推荐版本为22H2 Build 10.0.19045.2311，并且已经安装了编号为<a href="https://www.catalog.update.microsoft.com/Search.aspx?q=KB5014032">KB5014032</a>以及<a href="https://www.catalog.update.microsoft.com/Search.aspx?q=KB5022834">KB5022834</a>的系统补丁</p><p>其次，必须开启电脑的硬件虚拟化，否则无法运行</p><p>推荐开启的Windows服务：虚拟机平台（必须）、Windows 虚拟机监控程序平台（可选）、适用于 Linux 的 Windows 子系统（可选）、Hyper-V（可选）</p><p>注意：如果您之前安装过官方的WSA，则需要完全卸载</p><h5 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a><strong>硬件要求</strong></h5><p>内存最低8GB，推荐内存为16GB</p><p>确保C盘至少有10GB可用空间。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h4><p>前往<a href="https://github.com/A-JiuA/WSAOnWin10/releases">https://github.com/A-JiuA/WSAOnWin10/releases</a>下载您想要的版本。</p><p>注：MindTheGapps为自带谷歌应用商店，with-magisk为自带magisk，自行选择</p><p>下载到对应版本后，自行校对哈希值，校对完成后将压缩包解压，进入目录后运行Run.bat即可。</p><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a><strong>设置</strong></h4><p>*注：从这个仓库下载的所有版本均不带有系统桌面。各位请自行安装。</p><p>首先前往进阶设置，设置好所需内存与显卡。然后，<strong>开启开发者模式</strong>并且记住端口号。</p><p>由于没有系统桌面，且WSA采用虚拟磁盘，我们需要使用ADB进行文件管理、APK安装等活动。</p><p>推荐ADB工具：<a href="https://github.com/liangweihao/adb_tool">https://github.com/liangweihao/adb_tool</a></p><p>以这个工具为例，要在输入对方设备IP连接这一栏填写127.0.0.1:[端口号]</p><p>至此。一切已经结束。</p><h4 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a><strong>尾声</strong></h4><p>如后续需要更新版本，请前往WSA主设置面板，点击关闭Windows子系统Android™版。</p><p>然后彻底删除文件所在目录，重复上文你想要的版本的安装步骤即可</p><p>最后，enjoy🥰~</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抱脸部署FileCodeBox(database同步)</title>
      <link href="//post/26312.html"/>
      <url>//post/26312.html</url>
      
        <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/vastsa/FileCodeBox">https://github.com/vastsa/FileCodeBox</a></p><p>项目名称：FileCodeBox </p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>顾名思义，这个项目能够快速、高效地跨设备、跨网络链接实现文件、字符共享，可以自行设置过期时间&#x2F;次数。文件大小限制为20MB以内。</p><p>由于抱脸容器的特殊性（定时清空数据重启），我们需要设置database同步以达到不丢失数据。</p><h4 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h4><p>1.外网访问环境</p><p>2.一个huggingface账户</p><p>3.一点耐心</p><h4 id="必要环境变量"><a href="#必要环境变量" class="headerlink" title="必要环境变量"></a>必要环境变量</h4><p>1.huggingface自带的database服务仓库名</p><p>2.huggingface授权key</p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><h4 id="创建空间"><a href="#创建空间" class="headerlink" title="创建空间"></a>创建空间</h4><p>先前往space页面，单击New Space</p><p><img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image.png"></p><p>在space设置页面有几个需要填的东西</p><p>Space name：空间名称，决定域名部分（分配域名：用户名-空间名.hf.space）</p><p>Selet the Space SDK：选择Docker</p><p>Space harware：空间硬件配置，如果你不想多花冤枉钱就选择默认的free配置</p><p><img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image-uaia.png"></p><p>其他东西不用填，直接点击下方的Create Space</p><h4 id="存储库设置"><a href="#存储库设置" class="headerlink" title="存储库设置"></a>存储库设置</h4><p>点击个人头像，选择New Dataset<img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image-hdqa.png"></p><p>输入数据库名称，然后点击Create Dataset</p><p><img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image-wzeq.png"></p><p>这里的Datasets: xxxxx&#x2F;xxxxx将会作为DATASET_ID这个变量</p><p><img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image-ciqw.png"></p><h4 id="获取授权Key"><a href="#获取授权Key" class="headerlink" title="获取授权Key"></a>获取授权Key</h4><p>点击个人头像，前往Access Tokens 并输入密码进入</p><p><img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image-tkmw.png"></p><p>单击Creat new token</p><p>权限全部勾选（如果你懒得单独调）</p><p>创建后会返还以hf-xxxx开头的秘钥，这将作为HF_TOKEN这个变量使用。</p><h4 id="空间设置"><a href="#空间设置" class="headerlink" title="空间设置"></a>空间设置</h4><p>来到文件页面，选择README.md并在下方添加（如下图所示）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app_port: 12345</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/HongShi2333/HongShi2333.github.io/refs/heads/main/images/upload/image-bsdb.png"></p><p>然后转到Files选项卡，点击Add file并选择Create a new file</p><p>文件名为sync_data.sh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 检查环境变量</span><br><span class="line">if [ -z &quot;$HF_TOKEN&quot; ] || [ -z &quot;$DATASET_ID&quot; ]; then</span><br><span class="line">    echo &quot;Starting without backup functionality - missing HF_TOKEN or DATASET_ID&quot;</span><br><span class="line">    exec python main.py</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 登录HuggingFace (使用环境变量方式避免交互问题)</span><br><span class="line">export HUGGING_FACE_HUB_TOKEN=$HF_TOKEN</span><br><span class="line"></span><br><span class="line"># 同步函数</span><br><span class="line">sync_data() &#123;</span><br><span class="line">    while true; do</span><br><span class="line">        echo &quot;Starting sync process at $(date)&quot;</span><br><span class="line">  </span><br><span class="line">        # 创建临时压缩文件</span><br><span class="line">        cd /app</span><br><span class="line">        timestamp=$(date +%Y%m%d_%H%M%S)</span><br><span class="line">        backup_file=&quot;backup_$&#123;timestamp&#125;.tar.gz&quot;</span><br><span class="line">  </span><br><span class="line">        tar -czf &quot;/tmp/$&#123;backup_file&#125;&quot; data/</span><br><span class="line">  </span><br><span class="line">        python3 -c &quot;</span><br><span class="line">from huggingface_hub import HfApi</span><br><span class="line">import os</span><br><span class="line">def manage_backups(api, repo_id, max_files=2):</span><br><span class="line">    files = api.list_repo_files(repo_id=repo_id, repo_type=&#x27;dataset&#x27;)</span><br><span class="line">    backup_files = [f for f in files if f.startswith(&#x27;backup_&#x27;) and f.endswith(&#x27;.tar.gz&#x27;)]</span><br><span class="line">    backup_files.sort()</span><br><span class="line">  </span><br><span class="line">    if len(backup_files) &gt;= max_files:</span><br><span class="line">        files_to_delete = backup_files[:(len(backup_files) - max_files + 1)]</span><br><span class="line">        for file_to_delete in files_to_delete:</span><br><span class="line">            try:</span><br><span class="line">                api.delete_file(path_in_repo=file_to_delete, repo_id=repo_id, repo_type=&#x27;dataset&#x27;)</span><br><span class="line">                print(f&#x27;Deleted old backup: &#123;file_to_delete&#125;&#x27;)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                print(f&#x27;Error deleting &#123;file_to_delete&#125;: &#123;str(e)&#125;&#x27;)</span><br><span class="line">try:</span><br><span class="line">    api = HfApi()</span><br><span class="line">    api.upload_file(</span><br><span class="line">        path_or_fileobj=&#x27;/tmp/$&#123;backup_file&#125;&#x27;,</span><br><span class="line">        path_in_repo=&#x27;$&#123;backup_file&#125;&#x27;,</span><br><span class="line">        repo_id=&#x27;$&#123;DATASET_ID&#125;&#x27;,</span><br><span class="line">        repo_type=&#x27;dataset&#x27;</span><br><span class="line">    )</span><br><span class="line">    print(&#x27;Backup uploaded successfully&#x27;)</span><br><span class="line">  </span><br><span class="line">    manage_backups(api, &#x27;$&#123;DATASET_ID&#125;&#x27;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(f&#x27;Backup failed: &#123;str(e)&#125;&#x27;)</span><br><span class="line">&quot;</span><br><span class="line">        # 清理临时文件</span><br><span class="line">        rm -f &quot;/tmp/$&#123;backup_file&#125;&quot;</span><br><span class="line">  </span><br><span class="line">        # 设置同步间隔</span><br><span class="line">        SYNC_INTERVAL=$&#123;SYNC_INTERVAL:-72000&#125;</span><br><span class="line">        echo &quot;Next sync in $&#123;SYNC_INTERVAL&#125; seconds...&quot;</span><br><span class="line">        sleep $SYNC_INTERVAL</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 恢复函数</span><br><span class="line">restore_latest() &#123;</span><br><span class="line">    echo &quot;Attempting to restore latest backup...&quot;</span><br><span class="line">    python3 -c &quot;</span><br><span class="line">try:</span><br><span class="line">    from huggingface_hub import HfApi</span><br><span class="line">    import os</span><br><span class="line">  </span><br><span class="line">    api = HfApi()</span><br><span class="line">    files = api.list_repo_files(&#x27;$&#123;DATASET_ID&#125;&#x27;, repo_type=&#x27;dataset&#x27;)</span><br><span class="line">    backup_files = [f for f in files if f.startswith(&#x27;backup_&#x27;) and f.endswith(&#x27;.tar.gz&#x27;)]</span><br><span class="line">  </span><br><span class="line">    if backup_files:</span><br><span class="line">        latest = sorted(backup_files)[-1]</span><br><span class="line">        api.hf_hub_download(</span><br><span class="line">            repo_id=&#x27;$&#123;DATASET_ID&#125;&#x27;,</span><br><span class="line">            filename=latest,</span><br><span class="line">            repo_type=&#x27;dataset&#x27;,</span><br><span class="line">            local_dir=&#x27;/tmp&#x27;</span><br><span class="line">        )</span><br><span class="line">        os.system(f&#x27;tar -xzf /tmp/&#123;latest&#125; -C /app&#x27;)</span><br><span class="line">        os.remove(f&#x27;/tmp/&#123;latest&#125;&#x27;)</span><br><span class="line">        print(f&#x27;Restored from &#123;latest&#125;&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;No backup found&#x27;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(f&#x27;Restore failed: &#123;str(e)&#125;&#x27;)</span><br><span class="line">&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 主程序</span><br><span class="line">(</span><br><span class="line">    # 尝试恢复</span><br><span class="line">    restore_latest</span><br><span class="line">  </span><br><span class="line">    # 启动同步进程</span><br><span class="line">    sync_data &amp;</span><br><span class="line">  </span><br><span class="line">    # 启动主应用</span><br><span class="line">    exec python main.py</span><br><span class="line">) 2&gt;&amp;1 | tee -a /app/data/backup.log</span><br></pre></td></tr></table></figure><p>再次重复操作，文件名为Dockerfile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">FROM lanol/filecodebox:beta</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    python3-pip \</span><br><span class="line">    git \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">RUN pip3 install --no-cache-dir huggingface_hub datasets</span><br><span class="line"></span><br><span class="line">RUN useradd -m -u 1000 user</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">ENV HOME=/home/user \</span><br><span class="line">    PATH=/home/user/.local/bin:$PATH \</span><br><span class="line">    HF_HOME=/app/data/hf_cache \</span><br><span class="line">    PYTHONUNBUFFERED=1</span><br><span class="line"></span><br><span class="line">RUN mkdir -p /app/data &amp;&amp; \</span><br><span class="line">    chown -R user:user /app/data</span><br><span class="line"></span><br><span class="line">COPY sync_data.sh /app/</span><br><span class="line">RUN chmod +x /app/sync_data.sh &amp;&amp; \</span><br><span class="line">    chown user:user /app/sync_data.sh</span><br><span class="line"></span><br><span class="line">USER user</span><br><span class="line"></span><br><span class="line">EXPOSE 12345</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;/app/sync_data.sh&quot;]</span><br></pre></td></tr></table></figure><p>然后我们转到Setting选项卡，找到Variables and secrets</p><p>单击New Secret，并将下面的值键入</p><ul><li>DATASET_ID 存储库设置 步骤中的值，为用户名&#x2F;存储库ID</li><li>HF_TOKEN 获取授权Key 步骤中的值，为hf-xxxxxxxx格式</li><li>SYNC_INTERVAL 备份间隔时间，以秒为单位，推荐3600</li></ul><p>然后我们的项目就可以顺利的跑起来了</p>]]></content>
      
      
      <categories>
          
          <category> Huggingface </category>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
            <tag> Huggingface </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
